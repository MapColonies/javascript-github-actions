// Generated by Copilot
import * as core from '@actions/core';
import * as github from '@actions/github';

/**
 * Interface for Jira issue check result
 */
interface JiraCheckResult {
  hasJira: boolean;
  jiraIssue?: string;
}

/**
 * Interface for GitHub context information
 */
interface GitHubContextInfo {
  readonly owner: string;
  readonly repo: string;
  readonly prNumber: number;
  readonly prTitle: string;
  readonly prSha: string;
  readonly prAuthor: string | undefined;
}

/**
 * Constants for the action
 */
const JIRA_STATUS_CONTEXT = 'jira/issue-validation' as const;
const JIRA_COMMENT_IDENTIFIER = 'ðŸŽ« Related Jira Issue' as const;
const SUCCESS_STATE = 'success' as const;
const ERROR_STATE = 'error' as const;

/**
 * Checks if the pull request author is in the bypass list
 * @param prAuthor - The author of the pull request
 * @param bypassUsersInput - Comma-separated string of usernames to bypass
 * @returns True if the author is in the bypass list, false otherwise
 */
function isUserBypassed(prAuthor: string, bypassUsersInput: string): boolean {
  if (!bypassUsersInput.trim()) {
    return false;
  }

  const bypassUsers = bypassUsersInput.split(',').map((user) => user.trim());
  return bypassUsers.includes(prAuthor);
}

/**
 * Extracts Jira issue ID from PR title using regex pattern
 * @param title - The pull request title
 * @param pattern - The regex pattern to match Jira issues
 * @returns JiraCheckResult containing whether Jira issue was found and the issue ID
 */
function extractJiraIssue(title: string, pattern: string): JiraCheckResult {
  const regex = new RegExp(pattern);
  const match = title.match(regex);

  const hasMatchWithValue = match?.[0] !== undefined;
  if (hasMatchWithValue) {
    return {
      hasJira: true,
      jiraIssue: match[0],
    };
  }

  return { hasJira: false };
}

/**
 * Creates or updates commit status for Jira validation
 * @param octokit - GitHub API client
 * @param contextInfo - GitHub context information
 * @param jiraResult - Result of Jira issue check
 * @param jiraBaseUrl - Base URL for Jira instance
 */
async function setCommitStatus(
  octokit: ReturnType<typeof github.getOctokit>,
  contextInfo: GitHubContextInfo,
  jiraResult: JiraCheckResult,
  jiraBaseUrl: string
): Promise<void> {
  const { owner, repo, prSha } = contextInfo;
  const { hasJira, jiraIssue } = jiraResult;

  const statusState = hasJira ? SUCCESS_STATE : ERROR_STATE;
  const statusDescription = hasJira ? 'Jira issue found in PR title' : 'Jira issue required in PR title (format: MAPCO-1234)';
  const targetUrl = hasJira && jiraIssue !== undefined ? `${jiraBaseUrl}/browse/${jiraIssue}` : undefined;

  await octokit.rest.repos.createCommitStatus({
    owner,
    repo,
    sha: prSha,
    state: statusState,

    target_url: targetUrl,
    description: statusDescription,
    context: JIRA_STATUS_CONTEXT,
  });
}

/**
 * Finds existing bot comment with Jira link
 * @param octokit - GitHub API client
 * @param contextInfo - GitHub context information
 * @returns Comment ID if found, undefined otherwise
 */
async function findExistingJiraComment(octokit: ReturnType<typeof github.getOctokit>, contextInfo: GitHubContextInfo): Promise<number | undefined> {
  const { owner, repo, prNumber } = contextInfo;

  const comments = await octokit.rest.issues.listComments({
    owner,
    repo,

    issue_number: prNumber,
  });

  const existingComment = comments.data.find((comment) => {
    const isBotUser = comment.user?.type === 'Bot';
    const hasJiraIdentifier = comment.body?.includes(JIRA_COMMENT_IDENTIFIER) === true;
    return isBotUser && hasJiraIdentifier;
  });

  return existingComment?.id;
}

/**
 * Creates or updates Jira link comment on pull request
 * @param octokit - GitHub API client
 * @param contextInfo - GitHub context information
 * @param jiraIssue - The Jira issue ID
 * @param jiraBaseUrl - Base URL for Jira instance
 */
async function createOrUpdateJiraComment(
  octokit: ReturnType<typeof github.getOctokit>,
  contextInfo: GitHubContextInfo,
  jiraIssue: string,
  jiraBaseUrl: string
): Promise<void> {
  const { owner, repo, prNumber } = contextInfo;
  const jiraUrl = `${jiraBaseUrl}/browse/${jiraIssue}`;
  const commentBody = `ðŸŽ« **Related Jira Issue**: [${jiraIssue}](${jiraUrl})`;

  const existingCommentId = await findExistingJiraComment(octokit, contextInfo);

  if (existingCommentId !== undefined) {
    // Update existing comment
    await octokit.rest.issues.updateComment({
      owner,
      repo,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      comment_id: existingCommentId,
      body: commentBody,
    });
    core.info(`Updated existing Jira comment for issue: ${jiraIssue}`);
  } else {
    // Create new comment
    await octokit.rest.issues.createComment({
      owner,
      repo,

      issue_number: prNumber,
      body: commentBody,
    });
    core.info(`Created new Jira comment for issue: ${jiraIssue}`);
  }
}

/**
 * Parses comma-separated bypass labels from input
 * @param bypassLabelsInput - Comma-separated string of bypass labels
 * @returns Array of trimmed bypass labels
 */
function parseBypassLabels(bypassLabelsInput: string): readonly string[] {
  if (bypassLabelsInput === '') {
    return [];
  }

  return bypassLabelsInput
    .split(',')
    .map((label) => label.trim())
    .filter((label) => label !== '');
}

/**
 * Checks if PR has any bypass labels that would skip Jira validation
 * @param octokit - GitHub API client
 * @param contextInfo - GitHub context information
 * @param bypassLabels - Array of bypass label names
 * @returns True if PR has any bypass labels
 */
async function hasBypassLabels(
  octokit: ReturnType<typeof github.getOctokit>,
  contextInfo: GitHubContextInfo,
  bypassLabels: readonly string[]
): Promise<boolean> {
  // Early return if no bypass labels configured
  if (bypassLabels.length === 0) {
    return false;
  }

  const { owner, repo, prNumber } = contextInfo;

  // Fetch PR labels from GitHub API
  const response = await octokit.rest.issues.listLabelsOnIssue({
    owner,
    repo,

    issue_number: prNumber,
  });

  const prLabels = response.data.map((label) => label.name);

  // Check if any PR label matches bypass labels
  const hasBypassLabel = bypassLabels.some((bypassLabel) => prLabels.includes(bypassLabel));

  return hasBypassLabel;
}

/**
 * Main function that executes the GitHub action
 * @returns Promise<void>
 */
export async function run(): Promise<void> {
  try {
    // Get inputs from action.yaml
    const token = core.getInput('github-token') || process.env.GITHUB_TOKEN;
    const jiraBaseUrl = core.getInput('jira-base-url');
    const jiraIssuePattern = core.getInput('jira-issue-pattern') || 'MAPCO-\\d+';
    const bypassLabelsInput = core.getInput('bypass-labels');
    const bypassUsersInput = core.getInput('bypass-users');

    // Validate required inputs
    const hasToken = token !== undefined && token !== '';
    if (!hasToken) {
      core.setFailed('GitHub token is required');
      return;
    }

    const hasJiraBaseUrl = jiraBaseUrl !== '';
    if (!hasJiraBaseUrl) {
      core.setFailed('Jira base URL is required');
      return;
    }

    // Get GitHub context
    const context = github.context;
    const isPullRequestEvent = context.eventName === 'pull_request';

    if (!isPullRequestEvent) {
      core.warning('This action is designed to work with pull request events');
      return;
    }

    // Check if pull request payload exists
    const hasPullRequestPayload = context.payload.pull_request !== undefined;
    if (!hasPullRequestPayload) {
      core.setFailed('Pull request payload not found in context');
      return;
    }

    // Extract context information including PR author
    const { owner, repo } = context.repo;
    const prNumber = context.issue.number;
    const prTitle = (context.payload.pull_request?.title ?? '') as string;
    const prSha = (context.payload.pull_request as any)?.head?.sha as string;
    const prAuthor = (context.payload.pull_request as any)?.user?.login as string | undefined;

    const contextInfo: GitHubContextInfo = {
      owner,
      repo,
      prNumber,
      prTitle,
      prSha,
      prAuthor,
    };

    const octokit = github.getOctokit(token);

    core.info(`Processing PR #${contextInfo.prNumber}: "${contextInfo.prTitle}"`);

    // Check if PR author is in bypass list - early return if bypassed
    const isPrAuthorBypassed = prAuthor !== undefined && isUserBypassed(prAuthor, bypassUsersInput);
    if (isPrAuthorBypassed) {
      core.info(`PR author ${prAuthor} is in bypass list. Skipping Jira validation.`);
      await setCommitStatus(octokit, contextInfo, { hasJira: true, jiraIssue: undefined }, jiraBaseUrl);
      return;
    }

    // Parse bypass labels from input
    const bypassLabels = parseBypassLabels(bypassLabelsInput);
    core.info(`Parsed bypass labels: ${JSON.stringify(bypassLabels)}`);

    // Check if PR has bypass labels
    const prHasBypassLabels = await hasBypassLabels(octokit, contextInfo, bypassLabels);
    if (prHasBypassLabels) {
      core.info('PR has bypass labels, skipping Jira validation');
      await setCommitStatus(octokit, contextInfo, { hasJira: true, jiraIssue: undefined }, jiraBaseUrl);
      return;
    }

    // Extract Jira issue from PR title
    const jiraResult = extractJiraIssue(contextInfo.prTitle, jiraIssuePattern);

    const hasJiraIssue = jiraResult.hasJira && jiraResult.jiraIssue !== undefined;
    if (hasJiraIssue) {
      core.info(`Found Jira issue: ${jiraResult.jiraIssue}`);
    } else {
      core.warning('No Jira issue found in PR title');
    }

    // Set commit status based on Jira validation
    await setCommitStatus(octokit, contextInfo, jiraResult, jiraBaseUrl);
    core.info(`Set commit status: ${jiraResult.hasJira ? 'success' : 'error'}`);

    // Add or update Jira link comment if issue found
    if (hasJiraIssue && jiraResult.jiraIssue !== undefined) {
      await createOrUpdateJiraComment(octokit, contextInfo, jiraResult.jiraIssue, jiraBaseUrl);
    }

    core.info('Jira integration completed successfully');
  } catch (error) {
    console.log(error);

    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
    core.setFailed(`Action failed with error: ${errorMessage}`);
  }
}
