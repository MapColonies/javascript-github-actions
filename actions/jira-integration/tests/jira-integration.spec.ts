// Generated by Copilot
import { describe, it, expect, vi, beforeEach, afterEach, type MockedFunction } from 'vitest';
import { faker } from '@faker-js/faker';
import * as core from '@actions/core';
import * as github from '@actions/github';
import { fromPartial } from '@total-typescript/shoehorn';
import { run } from '../main.js';

// Mock the action modules
vi.mock('@actions/core');
vi.mock('@actions/github');

/**
 * Test suite for the jira-integration GitHub action
 */
describe('jira-integration Action', () => {
  let mockGetInput: MockedFunction<typeof core.getInput>;
  let mockSetFailed: MockedFunction<typeof core.setFailed>;
  let mockWarning: MockedFunction<typeof core.warning>;
  let mockGetOctokit: MockedFunction<typeof github.getOctokit>;
  let mockCreateComment: ReturnType<typeof vi.fn>;
  let mockUpdateComment: ReturnType<typeof vi.fn>;
  let mockListComments: ReturnType<typeof vi.fn>;
  let mockCreateCommitStatus: ReturnType<typeof vi.fn>;
  let mockListLabelsOnIssue: ReturnType<typeof vi.fn>;

  // Test data generated using faker
  let testToken: string;
  let testPrNumber: number;
  let testJiraBaseUrl: string;
  let testJiraPattern: string;
  let testJiraIssue: string;
  let testPrTitleWithJira: string;
  let testPrTitleWithoutJira: string;
  let testPrSha: string;
  let testOwner: string;
  let testRepo: string;
  let testBypassUser: string;
  let testNonBypassUser: string;

  beforeEach(() => {
    // Reset all mocks
    vi.clearAllMocks();

    // Generate test data
    testToken = faker.string.alphanumeric(40);
    testPrNumber = faker.number.int({ min: 1, max: 999 });
    testJiraBaseUrl = 'https://mapcolonies.atlassian.net';
    testJiraPattern = 'MAPCO-\\d+';
    testJiraIssue = `MAPCO-${faker.number.int({ min: 1000, max: 9999 })}`;
    testPrTitleWithJira = `feat: ${testJiraIssue} - ${faker.lorem.words(3)}`;
    testPrTitleWithoutJira = `feat: ${faker.lorem.words(3)}`;
    testPrSha = faker.git.commitSha();
    testOwner = faker.person.firstName().toLowerCase();
    testRepo = faker.lorem.word();

    // Mock core functions
    mockGetInput = vi.mocked(core.getInput);
    mockSetFailed = vi.mocked(core.setFailed);
    mockWarning = vi.mocked(core.warning);

    // Mock GitHub API functions
    mockCreateComment = vi.fn();
    mockUpdateComment = vi.fn();
    mockListComments = vi.fn();
    mockCreateCommitStatus = vi.fn();
    mockListLabelsOnIssue = vi.fn();

    mockGetOctokit = vi.mocked(github.getOctokit);
    mockGetOctokit.mockReturnValue(
      fromPartial({
        rest: {
          issues: {
            createComment: mockCreateComment as unknown as ReturnType<typeof github.getOctokit>['rest']['issues']['createComment'],
            updateComment: mockUpdateComment as unknown as ReturnType<typeof github.getOctokit>['rest']['issues']['updateComment'],
            listComments: mockListComments as unknown as ReturnType<typeof github.getOctokit>['rest']['issues']['listComments'],
            listLabelsOnIssue: mockListLabelsOnIssue as unknown as ReturnType<typeof github.getOctokit>['rest']['issues']['listLabelsOnIssue'],
          },
          repos: {
            createCommitStatus: mockCreateCommitStatus as unknown as ReturnType<typeof github.getOctokit>['rest']['repos']['createCommitStatus'],
          },
        },
      })
    );

    // Mock GitHub context
    Object.defineProperty(github, 'context', {
      value: {
        eventName: 'pull_request',
        repo: { owner: testOwner, repo: testRepo },
        issue: { number: testPrNumber },
        payload: {
          pull_request: {
            title: testPrTitleWithJira,
            head: { sha: testPrSha },
          },
        },
      },
      configurable: true,
    });
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  /**
   * Test successful Jira integration with valid issue in PR title
   */
  it('should create commit status and comment when Jira issue is found', async () => {
    mockGetInput.mockImplementation((name: string) => {
      if (name === 'github-token') return testToken;
      if (name === 'jira-base-url') return testJiraBaseUrl;
      if (name === 'jira-issue-pattern') return testJiraPattern;
      if (name === 'bypass-labels') return '';
      return '';
    });

    mockListComments.mockResolvedValue({ data: [] });

    await run();

    // Verify commit status was created with success state
    expect(mockCreateCommitStatus).toHaveBeenCalledWith({
      owner: testOwner,
      repo: testRepo,
      sha: testPrSha,
      state: 'success',

      target_url: `${testJiraBaseUrl}/browse/${testJiraIssue}`,
      description: 'Jira issue found in PR title',
      context: 'jira/issue-validation',
    });

    // Verify Jira comment was created
    expect(mockCreateComment).toHaveBeenCalledWith({
      owner: testOwner,
      repo: testRepo,
      issue_number: testPrNumber,
      body: `ðŸŽ« **Related Jira Issue**: [${testJiraIssue}](${testJiraBaseUrl}/browse/${testJiraIssue})`,
    });

    expect(mockSetFailed).not.toHaveBeenCalled();
  });

  /**
   * Test handling of PR without Jira issue in title
   */
  it('should create error commit status when no Jira issue is found', async () => {
    // Update context to use PR title without Jira issue
    Object.defineProperty(github, 'context', {
      value: {
        eventName: 'pull_request',
        repo: {
          owner: testOwner,
          repo: testRepo,
        },
        issue: {
          number: testPrNumber,
        },
        payload: {
          pull_request: {
            title: testPrTitleWithoutJira,
            head: {
              sha: testPrSha,
            },
          },
        },
      },
      writable: true,
    });

    mockGetInput.mockImplementation((name: string) => {
      if (name === 'github-token') return testToken;
      if (name === 'jira-base-url') return testJiraBaseUrl;
      if (name === 'jira-issue-pattern') return testJiraPattern;
      return '';
    });

    await run();

    // Verify commit status was created with error state
    expect(mockCreateCommitStatus).toHaveBeenCalledWith({
      owner: testOwner,
      repo: testRepo,
      sha: testPrSha,
      state: 'error',

      target_url: undefined,
      description: 'Jira issue required in PR title (format: MAPCO-1234)',
      context: 'jira/issue-validation',
    });

    // Verify no Jira comment was created
    expect(mockCreateComment).not.toHaveBeenCalled();
    expect(mockWarning).toHaveBeenCalledWith('No Jira issue found in PR title');
  });

  /**
   * Test updating existing Jira comment
   */
  it('should update existing Jira comment when one already exists', async () => {
    const existingCommentId = faker.number.int({ min: 100, max: 999 });
    const oldJiraIssue = `OLD-${faker.number.int({ min: 100, max: 999 })}`;
    const oldJiraUrl = `https://${faker.company.name().toLowerCase().replace(/\s+/g, '-')}.atlassian.net`;

    mockListComments.mockResolvedValue({
      data: [
        {
          id: existingCommentId,
          user: { type: 'Bot' },
          body: `ðŸŽ« Related Jira Issue: [${oldJiraIssue}](${oldJiraUrl}/browse/${oldJiraIssue})`,
        },
      ],
    });

    mockGetInput.mockImplementation((name: string) => {
      if (name === 'github-token') return testToken;
      if (name === 'jira-base-url') return testJiraBaseUrl;
      if (name === 'jira-issue-pattern') return testJiraPattern;
      return '';
    });

    await run();

    // Verify existing comment was updated instead of creating new one
    expect(mockUpdateComment).toHaveBeenCalledWith({
      owner: testOwner,
      repo: testRepo,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      comment_id: existingCommentId,
      body: `ðŸŽ« **Related Jira Issue**: [${testJiraIssue}](${testJiraBaseUrl}/browse/${testJiraIssue})`,
    });

    expect(mockCreateComment).not.toHaveBeenCalled();
  });

  /**
   * Test action fails when GitHub token is missing
   */
  it('should fail when GitHub token is missing', async () => {
    delete process.env.GITHUB_TOKEN;

    mockGetInput.mockImplementation((name: string) => {
      if (name === 'github-token') return '';
      if (name === 'jira-base-url') return testJiraBaseUrl;
      if (name === 'jira-issue-pattern') return testJiraPattern;
      return '';
    });

    await run();

    expect(mockSetFailed).toHaveBeenCalledWith('GitHub token is required');
    expect(mockCreateCommitStatus).not.toHaveBeenCalled();
    expect(mockCreateComment).not.toHaveBeenCalled();
  });

  /**
   * Test action fails when Jira base URL is missing
   */
  it('should fail when Jira base URL is missing', async () => {
    mockGetInput.mockImplementation((name: string) => {
      if (name === 'github-token') return testToken;
      if (name === 'jira-base-url') return '';
      if (name === 'jira-issue-pattern') return testJiraPattern;
      return '';
    });

    await run();

    expect(mockSetFailed).toHaveBeenCalledWith('Jira base URL is required');
    expect(mockCreateCommitStatus).not.toHaveBeenCalled();
    expect(mockCreateComment).not.toHaveBeenCalled();
  });

  /**
   * Test warning when not running on pull request event
   */
  it('should warn when not running on pull request event', async () => {
    Object.defineProperty(github, 'context', {
      value: {
        eventName: 'push',
        repo: {
          owner: testOwner,
          repo: testRepo,
        },
      },
      writable: true,
    });

    mockGetInput.mockImplementation((name: string) => {
      if (name === 'github-token') return testToken;
      if (name === 'jira-base-url') return testJiraBaseUrl;
      if (name === 'jira-issue-pattern') return testJiraPattern;
      return '';
    });

    await run();

    expect(mockWarning).toHaveBeenCalledWith('This action is designed to work with pull request events');
    expect(mockCreateCommitStatus).not.toHaveBeenCalled();
    expect(mockCreateComment).not.toHaveBeenCalled();
  });

  /**
   * Test error handling when pull request payload is missing
   */
  it('should fail when pull request payload is missing', async () => {
    Object.defineProperty(github, 'context', {
      value: {
        eventName: 'pull_request',
        repo: {
          owner: testOwner,
          repo: testRepo,
        },
        payload: {}, // Missing pull_request payload
      },
      writable: true,
    });

    mockGetInput.mockImplementation((name: string) => {
      if (name === 'github-token') return testToken;
      if (name === 'jira-base-url') return testJiraBaseUrl;
      if (name === 'jira-issue-pattern') return testJiraPattern;
      return '';
    });

    await run();

    expect(mockSetFailed).toHaveBeenCalledWith('Pull request payload not found in context');
    expect(mockCreateCommitStatus).not.toHaveBeenCalled();
  });

  /**
   * Test error handling when GitHub API calls fail
   */
  it('should handle API errors gracefully', async () => {
    const apiError = new Error(faker.lorem.sentence());

    mockGetInput.mockImplementation((name: string) => {
      if (name === 'github-token') return testToken;
      if (name === 'jira-base-url') return testJiraBaseUrl;
      if (name === 'jira-issue-pattern') return testJiraPattern;
      return '';
    });

    mockCreateCommitStatus.mockRejectedValue(apiError);

    await run();

    expect(mockSetFailed).toHaveBeenCalledWith(`Action failed: ${apiError.message}`);
  });

  /**
   * Test handling of unknown error types
   */
  it('should handle unknown errors', async () => {
    const unknownError = faker.lorem.words(3);

    mockGetInput.mockImplementation((name: string) => {
      if (name === 'github-token') return testToken;
      if (name === 'jira-base-url') return testJiraBaseUrl;
      if (name === 'jira-issue-pattern') return testJiraPattern;
      return '';
    });

    mockCreateCommitStatus.mockRejectedValue(unknownError);

    await run();

    expect(mockSetFailed).toHaveBeenCalledWith('Action failed: Unknown error occurred');
  });

  /**
   * Test custom Jira issue pattern matching
   */
  it('should work with custom Jira issue pattern', async () => {
    const customProject = faker.string.alpha({ length: { min: 3, max: 5 } }).toUpperCase();
    const customPattern = `${customProject}-\\d+`;
    const customIssue = `${customProject}-${faker.number.int({ min: 1000, max: 9999 })}`;
    const customTitle = `${customIssue}: ${faker.hacker.phrase()}`;

    Object.defineProperty(github, 'context', {
      value: {
        eventName: 'pull_request',
        repo: {
          owner: testOwner,
          repo: testRepo,
        },
        issue: {
          number: testPrNumber,
        },
        payload: {
          pull_request: {
            title: customTitle,
            head: {
              sha: testPrSha,
            },
          },
        },
      },
      writable: true,
    });

    mockGetInput.mockImplementation((name: string) => {
      if (name === 'github-token') return testToken;
      if (name === 'jira-base-url') return testJiraBaseUrl;
      if (name === 'jira-issue-pattern') return customPattern;
      return '';
    });

    await run();

    expect(mockCreateCommitStatus).toHaveBeenCalledWith({
      owner: testOwner,
      repo: testRepo,
      sha: testPrSha,
      state: 'success',

      target_url: `${testJiraBaseUrl}/browse/${customIssue}`,
      description: 'Jira issue found in PR title',
      context: 'jira/issue-validation',
    });
  });

  /**
   * Test action with default jira pattern when no pattern provided
   */
  it('should use default MAPCO pattern when no jira-issue-pattern is provided', async () => {
    mockGetInput.mockImplementation((name: string) => {
      if (name === 'github-token') return testToken;
      if (name === 'jira-base-url') return testJiraBaseUrl;
      if (name === 'jira-issue-pattern') return ''; // Empty pattern should use default
      return '';
    });

    await run();

    // Should still work with default MAPCO pattern
    expect(mockCreateCommitStatus).toHaveBeenCalledWith({
      owner: testOwner,
      repo: testRepo,
      sha: testPrSha,
      state: 'success',
      target_url: `${testJiraBaseUrl}/browse/${testJiraIssue}`,
      description: 'Jira issue found in PR title',
      context: 'jira/issue-validation',
    });
  });

  /**
   * Test bypass labels functionality - should skip validation when bypass labels are present
   */
  it('should skip Jira validation when PR author is in bypass list', async () => {
    // Generated by Copilot
    testBypassUser = 'dependabot[bot]';

    mockGetInput.mockImplementation((name: string) => {
      switch (name) {
        case 'github-token':
          return testToken;
        case 'jira-base-url':
          return testJiraBaseUrl;
        case 'jira-issue-pattern':
          return testJiraPattern;
        case 'bypass-users':
          return testBypassUser;
        default:
          return '';
      }
    });

    // Set PR author to be in bypass list
    github.context.payload.pull_request!.user = { login: testBypassUser };
    github.context.payload.pull_request!.title = testPrTitleWithoutJira; // No Jira issue in title

    await run();

    expect(mockSetFailed).not.toHaveBeenCalled();
    expect(mockCreateCommitStatus).toHaveBeenCalledWith({
      owner: testOwner,
      repo: testRepo,
      sha: testPrSha,
      state: 'success',
      target_url: undefined,
      description: 'Jira issue found in PR title',
      context: 'jira/issue-validation',
    });
  });

  /**
   * Test that Jira validation proceeds when PR author is not in bypass list
   */
  it('should perform Jira validation when PR author is not in bypass list', async () => {
    // Generated by Copilot
    testNonBypassUser = 'regular-user';

    mockGetInput.mockImplementation((name: string) => {
      switch (name) {
        case 'github-token':
          return testToken;
        case 'jira-base-url':
          return testJiraBaseUrl;
        case 'jira-issue-pattern':
          return testJiraPattern;
        case 'bypass-users':
          return 'dependabot[bot]'; // Different from PR author
        default:
          return '';
      }
    });

    // Set PR author to NOT be in bypass list
    github.context.payload.pull_request!.user = { login: testNonBypassUser };
    github.context.payload.pull_request!.title = testPrTitleWithoutJira; // No Jira issue in title

    await run();

    expect(mockSetFailed).not.toHaveBeenCalled();
    expect(mockCreateCommitStatus).toHaveBeenCalledWith({
      owner: testOwner,
      repo: testRepo,
      sha: testPrSha,
      state: 'error',
      target_url: undefined,
      description: 'Jira issue required in PR title (format: MAPCO-1234)',
      context: 'jira/issue-validation',
    });
  });

  /**
   * Test bypass users with multiple users in comma-separated list
   */
  it('should handle multiple bypass users in comma-separated list', async () => {
    // Generated by Copilot
    const bypassUsers = 'dependabot[bot],mapcolonies-devops,another-bot';

    mockGetInput.mockImplementation((name: string) => {
      switch (name) {
        case 'github-token':
          return testToken;
        case 'jira-base-url':
          return testJiraBaseUrl;
        case 'jira-issue-pattern':
          return testJiraPattern;
        case 'bypass-users':
          return bypassUsers;
        default:
          return '';
      }
    });

    // Test with second user in the list
    github.context.payload.pull_request!.user = { login: 'mapcolonies-devops' };
    github.context.payload.pull_request!.title = testPrTitleWithoutJira;

    await run();

    expect(mockSetFailed).not.toHaveBeenCalled();
    expect(mockCreateCommitStatus).toHaveBeenCalledWith({
      owner: testOwner,
      repo: testRepo,
      sha: testPrSha,
      state: 'success',
      target_url: undefined,
      description: 'Jira issue found in PR title',
      context: 'jira/issue-validation',
    });
  });

  /**
   * Test bypass users with multiple users in comma-separated list
   */
  it('should handle bypass a single user list', async () => {
    // Generated by Copilot
    const bypassUsers = 'mapcolonies-devops';

    mockGetInput.mockImplementation((name: string) => {
      switch (name) {
        case 'github-token':
          return testToken;
        case 'jira-base-url':
          return testJiraBaseUrl;
        case 'jira-issue-pattern':
          return testJiraPattern;
        case 'bypass-users':
          return bypassUsers;
        default:
          return '';
      }
    });

    // Test with second user in the list
    github.context.payload.pull_request!.user = { login: 'mapcolonies-devops' };
    github.context.payload.pull_request!.title = testPrTitleWithoutJira;

    await run();

    expect(mockSetFailed).not.toHaveBeenCalled();
    expect(mockCreateCommitStatus).toHaveBeenCalledWith({
      owner: testOwner,
      repo: testRepo,
      sha: testPrSha,
      state: 'success',
      target_url: undefined,
      description: 'Jira issue found in PR title',
      context: 'jira/issue-validation',
    });
  });

  /**
   * Test empty bypass users input
   */
  it('should perform normal validation when bypass-users is empty', async () => {
    // Generated by Copilot
    mockGetInput.mockImplementation((name: string) => {
      switch (name) {
        case 'github-token':
          return testToken;
        case 'jira-base-url':
          return testJiraBaseUrl;
        case 'jira-issue-pattern':
          return testJiraPattern;
        case 'bypass-users':
          return ''; // Empty bypass users
        default:
          return '';
      }
    });

    github.context.payload.pull_request!.user = { login: 'dependabot[bot]' };
    github.context.payload.pull_request!.title = testPrTitleWithoutJira;

    await run();

    expect(mockSetFailed).not.toHaveBeenCalled();
    // Should not skip validation even though user could be a bypass user
    expect(mockCreateCommitStatus).toHaveBeenCalledWith({
      owner: testOwner,
      repo: testRepo,
      sha: testPrSha,
      state: 'error',
      target_url: undefined,
      description: 'Jira issue required in PR title (format: MAPCO-1234)',
      context: 'jira/issue-validation',
    });
  });
});
