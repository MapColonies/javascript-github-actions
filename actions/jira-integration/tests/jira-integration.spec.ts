// Generated by Copilot
import { describe, it, expect, vi, beforeEach, afterEach, type MockedFunction } from 'vitest';
import { faker } from '@faker-js/faker';
import * as core from '@actions/core';
import * as github from '@actions/github';
import { run } from '../main.js';

// Mock the action modules
vi.mock('@actions/core');
vi.mock('@actions/github');

/**
 * Test suite for the jira-integration GitHub action
 */
describe('jira-integration Action', () => {
  let mockGetInput: MockedFunction<typeof core.getInput>;
  let mockSetFailed: MockedFunction<typeof core.setFailed>;
  let mockWarning: MockedFunction<typeof core.warning>;
  let mockInfo: MockedFunction<typeof core.info>;
  let mockGetOctokit: MockedFunction<typeof github.getOctokit>;
  let mockCreateComment: ReturnType<typeof vi.fn>;
  let mockUpdateComment: ReturnType<typeof vi.fn>;
  let mockListComments: ReturnType<typeof vi.fn>;
  let mockCreateCommitStatus: ReturnType<typeof vi.fn>;

  // Test data generated using faker
  let testToken: string;
  let testPrNumber: number;
  let testJiraBaseUrl: string;
  let testJiraPattern: string;
  let testJiraIssue: string;
  let testPrTitleWithJira: string;
  let testPrTitleWithoutJira: string;
  let testPrSha: string;
  let testOwner: string;
  let testRepo: string;

  beforeEach(() => {
    // Reset all mocks before each test
    vi.clearAllMocks();

    // Generate fresh test data for each test
    testToken = faker.string.alphanumeric(40);
    testPrNumber = faker.number.int({ min: 1, max: 9999 });
    testJiraBaseUrl = `https://${faker.company.name().toLowerCase().replace(/\s+/g, '-')}.atlassian.net`;
    testJiraPattern = 'MAPCO-\\d+';
    testJiraIssue = `MAPCO-${faker.number.int({ min: 1000, max: 9999 })}`;
    testPrTitleWithJira = `${testJiraIssue}: ${faker.hacker.phrase()}`;
    testPrTitleWithoutJira = faker.hacker.phrase();
    testPrSha = faker.git.commitSha();
    testOwner = faker.internet.username();
    testRepo = faker.system.fileName().replace(/\./g, '-').split('.')[0] ?? faker.word.noun();

    // Setup mock functions
    mockGetInput = vi.mocked(core.getInput);
    mockSetFailed = vi.mocked(core.setFailed);
    mockWarning = vi.mocked(core.warning);
    mockInfo = vi.mocked(core.info);
    mockGetOctokit = vi.mocked(github.getOctokit);
    mockCreateComment = vi.fn().mockResolvedValue({});
    mockUpdateComment = vi.fn().mockResolvedValue({});
    mockListComments = vi.fn().mockResolvedValue({ data: [] });
    mockCreateCommitStatus = vi.fn().mockResolvedValue({});

    // Set up default github context with pull request payload
    Object.defineProperty(github, 'context', {
      value: {
        eventName: 'pull_request',
        repo: {
          owner: testOwner,
          repo: testRepo,
        },
        issue: {
          number: testPrNumber,
        },
        payload: {
          // eslint-disable-next-line @typescript-eslint/naming-convention
          pull_request: {
            title: testPrTitleWithJira,
            head: {
              sha: testPrSha,
            },
          },
        },
      },
      writable: true,
    });

    // Mock octokit with all required methods
    mockGetOctokit.mockReturnValue({
      rest: {
        issues: {
          createComment: mockCreateComment,
          updateComment: mockUpdateComment,
          listComments: mockListComments,
        },
        repos: {
          createCommitStatus: mockCreateCommitStatus,
        },
      },
    } as unknown as ReturnType<typeof github.getOctokit>);

    // Set up environment
    process.env.GITHUB_TOKEN = testToken;
  });

  afterEach(() => {
    delete process.env.GITHUB_TOKEN;
  });

  /**
   * Test successful Jira integration with valid issue in PR title
   */
  it('should create commit status and comment when Jira issue is found', async () => {
    mockGetInput.mockImplementation((name: string) => {
      if (name === 'github-token') return testToken;
      if (name === 'jira-base-url') return testJiraBaseUrl;
      if (name === 'jira-issue-pattern') return testJiraPattern;
      return '';
    });

    await run();

    // Verify commit status was created with success state
    expect(mockCreateCommitStatus).toHaveBeenCalledWith({
      owner: testOwner,
      repo: testRepo,
      sha: testPrSha,
      state: 'success',
      // eslint-disable-next-line @typescript-eslint/naming-convention
      target_url: `${testJiraBaseUrl}/browse/${testJiraIssue}`,
      description: 'Jira issue found in PR title',
      context: 'jira/issue-validation',
    });

    // Verify Jira comment was created
    expect(mockCreateComment).toHaveBeenCalledWith({
      owner: testOwner,
      repo: testRepo,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      issue_number: testPrNumber,
      body: `ðŸŽ« **Related Jira Issue**: [${testJiraIssue}](${testJiraBaseUrl}/browse/${testJiraIssue})`,
    });

    expect(mockInfo).toHaveBeenCalledWith(`Found Jira issue: ${testJiraIssue}`);
    expect(mockInfo).toHaveBeenCalledWith('Set commit status: success');
    expect(mockSetFailed).not.toHaveBeenCalled();
  });

  /**
   * Test handling of PR without Jira issue in title
   */
  it('should create error commit status when no Jira issue is found', async () => {
    // Update context to use PR title without Jira issue
    Object.defineProperty(github, 'context', {
      value: {
        eventName: 'pull_request',
        repo: {
          owner: testOwner,
          repo: testRepo,
        },
        issue: {
          number: testPrNumber,
        },
        payload: {
          // eslint-disable-next-line @typescript-eslint/naming-convention
          pull_request: {
            title: testPrTitleWithoutJira,
            head: {
              sha: testPrSha,
            },
          },
        },
      },
      writable: true,
    });

    mockGetInput.mockImplementation((name: string) => {
      if (name === 'github-token') return testToken;
      if (name === 'jira-base-url') return testJiraBaseUrl;
      if (name === 'jira-issue-pattern') return testJiraPattern;
      return '';
    });

    await run();

    // Verify commit status was created with error state
    expect(mockCreateCommitStatus).toHaveBeenCalledWith({
      owner: testOwner,
      repo: testRepo,
      sha: testPrSha,
      state: 'error',
      // eslint-disable-next-line @typescript-eslint/naming-convention
      target_url: undefined,
      description: 'Jira issue required in PR title (format: MAPCO-1234)',
      context: 'jira/issue-validation',
    });

    // Verify no Jira comment was created
    expect(mockCreateComment).not.toHaveBeenCalled();
    expect(mockWarning).toHaveBeenCalledWith('No Jira issue found in PR title');
    expect(mockInfo).toHaveBeenCalledWith('Set commit status: error');
  });

  /**
   * Test updating existing Jira comment
   */
  it('should update existing Jira comment when one already exists', async () => {
    const existingCommentId = faker.number.int({ min: 100, max: 999 });
    const oldJiraIssue = `OLD-${faker.number.int({ min: 100, max: 999 })}`;
    const oldJiraUrl = `https://${faker.company.name().toLowerCase().replace(/\s+/g, '-')}.atlassian.net`;

    mockListComments.mockResolvedValue({
      data: [
        {
          id: existingCommentId,
          user: { type: 'Bot' },
          body: `ðŸŽ« Related Jira Issue: [${oldJiraIssue}](${oldJiraUrl}/browse/${oldJiraIssue})`,
        },
      ],
    });

    mockGetInput.mockImplementation((name: string) => {
      if (name === 'github-token') return testToken;
      if (name === 'jira-base-url') return testJiraBaseUrl;
      if (name === 'jira-issue-pattern') return testJiraPattern;
      return '';
    });

    await run();

    // Verify existing comment was updated instead of creating new one
    expect(mockUpdateComment).toHaveBeenCalledWith({
      owner: testOwner,
      repo: testRepo,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      comment_id: existingCommentId,
      body: `ðŸŽ« **Related Jira Issue**: [${testJiraIssue}](${testJiraBaseUrl}/browse/${testJiraIssue})`,
    });

    expect(mockCreateComment).not.toHaveBeenCalled();
    expect(mockInfo).toHaveBeenCalledWith(`Updated existing Jira comment for issue: ${testJiraIssue}`);
  });

  /**
   * Test action fails when GitHub token is missing
   */
  it('should fail when GitHub token is missing', async () => {
    delete process.env.GITHUB_TOKEN;

    mockGetInput.mockImplementation((name: string) => {
      if (name === 'github-token') return '';
      if (name === 'jira-base-url') return testJiraBaseUrl;
      if (name === 'jira-issue-pattern') return testJiraPattern;
      return '';
    });

    await run();

    expect(mockSetFailed).toHaveBeenCalledWith('GitHub token is required');
    expect(mockCreateCommitStatus).not.toHaveBeenCalled();
    expect(mockCreateComment).not.toHaveBeenCalled();
  });

  /**
   * Test action fails when Jira base URL is missing
   */
  it('should fail when Jira base URL is missing', async () => {
    mockGetInput.mockImplementation((name: string) => {
      if (name === 'github-token') return testToken;
      if (name === 'jira-base-url') return '';
      if (name === 'jira-issue-pattern') return testJiraPattern;
      return '';
    });

    await run();

    expect(mockSetFailed).toHaveBeenCalledWith('Jira base URL is required');
    expect(mockCreateCommitStatus).not.toHaveBeenCalled();
    expect(mockCreateComment).not.toHaveBeenCalled();
  });

  /**
   * Test warning when not running on pull request event
   */
  it('should warn when not running on pull request event', async () => {
    Object.defineProperty(github, 'context', {
      value: {
        eventName: 'push',
        repo: {
          owner: testOwner,
          repo: testRepo,
        },
      },
      writable: true,
    });

    mockGetInput.mockImplementation((name: string) => {
      if (name === 'github-token') return testToken;
      if (name === 'jira-base-url') return testJiraBaseUrl;
      if (name === 'jira-issue-pattern') return testJiraPattern;
      return '';
    });

    await run();

    expect(mockWarning).toHaveBeenCalledWith('This action is designed to work with pull request events');
    expect(mockCreateCommitStatus).not.toHaveBeenCalled();
    expect(mockCreateComment).not.toHaveBeenCalled();
  });

  /**
   * Test error handling when pull request payload is missing
   */
  it('should fail when pull request payload is missing', async () => {
    Object.defineProperty(github, 'context', {
      value: {
        eventName: 'pull_request',
        repo: {
          owner: testOwner,
          repo: testRepo,
        },
        payload: {}, // Missing pull_request payload
      },
      writable: true,
    });

    mockGetInput.mockImplementation((name: string) => {
      if (name === 'github-token') return testToken;
      if (name === 'jira-base-url') return testJiraBaseUrl;
      if (name === 'jira-issue-pattern') return testJiraPattern;
      return '';
    });

    await run();

    expect(mockSetFailed).toHaveBeenCalledWith('Pull request payload not found in context');
    expect(mockCreateCommitStatus).not.toHaveBeenCalled();
  });

  /**
   * Test error handling when GitHub API calls fail
   */
  it('should handle API errors gracefully', async () => {
    const apiError = new Error(faker.lorem.sentence());

    mockGetInput.mockImplementation((name: string) => {
      if (name === 'github-token') return testToken;
      if (name === 'jira-base-url') return testJiraBaseUrl;
      if (name === 'jira-issue-pattern') return testJiraPattern;
      return '';
    });

    mockCreateCommitStatus.mockRejectedValue(apiError);

    await run();

    expect(mockSetFailed).toHaveBeenCalledWith(`Action failed with error: ${apiError.message}`);
  });

  /**
   * Test handling of unknown error types
   */
  it('should handle unknown errors', async () => {
    const unknownError = faker.lorem.words(3);

    mockGetInput.mockImplementation((name: string) => {
      if (name === 'github-token') return testToken;
      if (name === 'jira-base-url') return testJiraBaseUrl;
      if (name === 'jira-issue-pattern') return testJiraPattern;
      return '';
    });

    mockCreateCommitStatus.mockRejectedValue(unknownError);

    await run();

    expect(mockSetFailed).toHaveBeenCalledWith('Action failed with error: Unknown error occurred');
  });

  /**
   * Test custom Jira issue pattern matching
   */
  it('should work with custom Jira issue pattern', async () => {
    const customProject = faker.string.alpha({ length: { min: 3, max: 5 } }).toUpperCase();
    const customPattern = `${customProject}-\\d+`;
    const customIssue = `${customProject}-${faker.number.int({ min: 1000, max: 9999 })}`;
    const customTitle = `${customIssue}: ${faker.hacker.phrase()}`;

    Object.defineProperty(github, 'context', {
      value: {
        eventName: 'pull_request',
        repo: {
          owner: testOwner,
          repo: testRepo,
        },
        issue: {
          number: testPrNumber,
        },
        payload: {
          // eslint-disable-next-line @typescript-eslint/naming-convention
          pull_request: {
            title: customTitle,
            head: {
              sha: testPrSha,
            },
          },
        },
      },
      writable: true,
    });

    mockGetInput.mockImplementation((name: string) => {
      if (name === 'github-token') return testToken;
      if (name === 'jira-base-url') return testJiraBaseUrl;
      if (name === 'jira-issue-pattern') return customPattern;
      return '';
    });

    await run();

    expect(mockCreateCommitStatus).toHaveBeenCalledWith({
      owner: testOwner,
      repo: testRepo,
      sha: testPrSha,
      state: 'success',
      // eslint-disable-next-line @typescript-eslint/naming-convention
      target_url: `${testJiraBaseUrl}/browse/${customIssue}`,
      description: 'Jira issue found in PR title',
      context: 'jira/issue-validation',
    });

    expect(mockInfo).toHaveBeenCalledWith(`Found Jira issue: ${customIssue}`);
  });

  /**
   * Test action with default jira pattern when no pattern provided
   */
  it('should use default MAPCO pattern when no jira-issue-pattern is provided', async () => {
    mockGetInput.mockImplementation((name: string) => {
      if (name === 'github-token') return testToken;
      if (name === 'jira-base-url') return testJiraBaseUrl;
      if (name === 'jira-issue-pattern') return ''; // Empty pattern should use default
      return '';
    });

    await run();

    // Should still work with default MAPCO pattern
    expect(mockCreateCommitStatus).toHaveBeenCalledWith({
      owner: testOwner,
      repo: testRepo,
      sha: testPrSha,
      state: 'success',
      // eslint-disable-next-line @typescript-eslint/naming-convention
      target_url: `${testJiraBaseUrl}/browse/${testJiraIssue}`,
      description: 'Jira issue found in PR title',
      context: 'jira/issue-validation',
    });
  });

  /**
   * Test that only Bot comments are considered for updates
   */
  it('should only update Bot comments, not user comments with Jira identifiers', async () => {
    const existingCommentId = faker.number.int({ min: 100, max: 999 });
    const userCommentId = faker.number.int({ min: 1000, max: 1999 });

    mockListComments.mockResolvedValue({
      data: [
        {
          id: userCommentId,
          user: { type: 'User' }, // Not a bot comment
          body: 'ðŸŽ« Related Jira Issue: [USER-123](https://example.com)',
        },
        {
          id: existingCommentId,
          user: { type: 'Bot' }, // Bot comment
          body: 'ðŸŽ« Related Jira Issue: [OLD-123](https://old-url.com)',
        },
      ],
    });

    mockGetInput.mockImplementation((name: string) => {
      if (name === 'github-token') return testToken;
      if (name === 'jira-base-url') return testJiraBaseUrl;
      if (name === 'jira-issue-pattern') return testJiraPattern;
      return '';
    });

    await run();

    // Should update the Bot comment, not the user comment
    expect(mockUpdateComment).toHaveBeenCalledWith({
      owner: testOwner,
      repo: testRepo,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      comment_id: existingCommentId, // Bot comment ID, not user comment ID
      body: `ðŸŽ« **Related Jira Issue**: [${testJiraIssue}](${testJiraBaseUrl}/browse/${testJiraIssue})`,
    });

    expect(mockCreateComment).not.toHaveBeenCalled();
  });
});
