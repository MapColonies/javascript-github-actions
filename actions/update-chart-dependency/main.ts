/**
 * @file Main entry for the Helm chart dependency update GitHub Action.
 * @author Generated by Copilot
 * @description Updates Chart.yaml for Helm charts and opens PRs.
 * @remarks Generated by Copilot
 */

import * as fs from 'fs';
import * as path from 'path';
import { getInput, setFailed, info, warning } from '@actions/core';
import { getOctokit, context as githubContext } from '@actions/github';

/**
 * @typedef ActionInputs - Inputs for the action
 */
interface ActionInputs {
  readonly serviceName: string;
  readonly version: string;
  readonly githubToken: string;
  readonly chartPrefix: string;
  readonly branch: string;
}

/**
 * @typedef UpdateResult - Result of file update
 */
interface UpdateResult {
  updated: boolean;
  oldVersion?: string;
  newVersion?: string;
  newContent?: string;
}

/**
 * @constant CHART_FILE_NAME - Chart.yaml filename
 */
const CHART_FILE_NAME = 'Chart.yaml' as const;
/**
 * @constant HELMFILE_NAME - helmfile.yaml filename
 */
const HELMFILE_NAME = 'helmfile.yaml' as const;
/**
 * @constant PR_TITLE_PREFIX - PR title prefix
 */
const PR_TITLE_PREFIX = 'Update Helm chart dependencies: ' as const;
/**
 * @constant DEFAULT_BASE_BRANCH - Default base branch for PR
 */
const DEFAULT_BASE_BRANCH = 'main' as const;

/**
 * @description Get action inputs from core
 * @returns ActionInputs
 */
function getInputs(): ActionInputs {
  // Generated by Copilot
  const serviceName = getInput('service-name');
  const version = getInput('version');
  const githubToken = getInput('github-token');
  const chartPrefix = getInput('chart-prefix') || '';
  const branch = getInput('branch') || DEFAULT_BASE_BRANCH;
  return { serviceName, version, githubToken, chartPrefix, branch };
}

/**
 * @description Find Chart.yaml and helmfile.yaml for the given chart directory
 * @param chartDir - chart directory name
 * @returns absolute paths to Chart.yaml and helmfile.yaml (if exist)
 */
function findChartFiles(chartDir: string): string[] {
  // Generated by Copilot
  const workspace = process.env.GITHUB_WORKSPACE ?? process.cwd();
  const chartPath = path.join(workspace, chartDir, CHART_FILE_NAME);
  const helmfilePath = path.join(workspace, chartDir, HELMFILE_NAME);

  const files: string[] = [];
  if (fs.existsSync(chartPath)) {
    files.push(chartPath);
  }
  if (fs.existsSync(helmfilePath)) {
    files.push(helmfilePath);
  }
  return files;
}

/**
 * @description Update dependency version for a given service in Chart.yaml or helmfile.yaml
 * @param filePath - path to file
 * @param dependencyName - name of the dependency/service to update
 * @param version - new version
 * @returns UpdateResult
 */
function updateDependencyVersion(filePath: string, dependencyName: string, version: string): UpdateResult {
  // Generated by Copilot
  const DEPENDENCIES_FIELD = 'dependencies:' as const;
  const NAME_FIELD = 'name:' as const;
  const VERSION_FIELD = 'version:' as const;
  const INDENTATION = '  '; // 2 spaces for yaml indentation

  const fileContent = fs.readFileSync(filePath, 'utf8');
  const lines = fileContent.split('\n');
  let inDependencies = false;
  let dependencyFound = false;
  let updated = false;
  let oldVersion: string | undefined;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (line.trim().startsWith(DEPENDENCIES_FIELD)) {
      inDependencies = true;
      continue;
    }
    if (inDependencies) {
      // End dependencies block if next top-level field starts
      if (/^[^ ]/.test(line) && line.trim() !== '') {
        inDependencies = false;
        continue;
      }
      // Check for dependency name
      if (line.trim().startsWith(NAME_FIELD)) {
        const nameValue = line.split(':')[1].trim();
        if (nameValue === dependencyName) {
          dependencyFound = true;
          // Search for version field in subsequent lines
          for (let j = i + 1; j < lines.length; j++) {
            const depLine = lines[j];
            // End of this dependency block if next name or top-level field
            if (depLine.trim().startsWith(NAME_FIELD) || /^[^ ]/.test(depLine)) {
              break;
            }
            if (depLine.trim().startsWith(VERSION_FIELD)) {
              const versionValue = depLine.split(':')[1].trim();
              oldVersion = versionValue;
              if (versionValue === version) {
                // Already up to date
                return { updated: false, oldVersion, newVersion: version };
              }
              // Update version line
              lines[j] = `${INDENTATION}${VERSION_FIELD} ${version}`;
              updated = true;
              break;
            }
          }
        }
      }
    }
  }

  if (!dependencyFound) {
    // No matching dependency found, skip update
    return { updated: false };
  }
  if (!updated) {
    // Dependency found but no version field found
    return { updated: false };
  }
  const newContent = lines.join('\n');
  return { updated: true, oldVersion, newVersion: version, newContent };
}

/**
 * @description Get the SHA of a file in a branch
 * @param octokit - github client
 * @param owner - repo owner
 * @param repo - repo name
 * @param path - file path
 * @param branch - branch name
 * @returns SHA string or undefined
 */
async function getFileSha(
  octokit: ReturnType<typeof getOctokit>,
  owner: string,
  repo: string,
  path: string,
  branch: string
): Promise<string | undefined> {
  try {
    const { data } = await octokit.rest.repos.getContent({
      owner,
      repo,
      path,
      ref: branch,
    });
    if ('sha' in data) {
      return data.sha;
    }
    return undefined;
  } catch {
    return undefined;
  }
}

/**
 * @description Create a new branch from base branch using GitHub API
 * @param octokit - github client
 * @param owner - repo owner
 * @param repo - repo name
 * @param baseBranch - base branch name
 * @param newBranch - new branch name
 */
async function createBranch(
  octokit: ReturnType<typeof getOctokit>,
  owner: string,
  repo: string,
  baseBranch: string,
  newBranch: string
): Promise<void> {
  // Get base branch ref
  const baseRef = `heads/${baseBranch}`;
  const { data: baseBranchData } = await octokit.rest.git.getRef({
    owner,
    repo,
    ref: baseRef,
  });
  const baseSha = baseBranchData.object.sha;
  // Create new branch ref
  await octokit.rest.git.createRef({
    owner,
    repo,
    ref: `refs/heads/${newBranch}`,
    sha: baseSha,
  });
}

/**
 * @description Update files in the new branch using GitHub API
 * @param octokit - github client
 * @param owner - repo owner
 * @param repo - repo name
 * @param branchName - branch name
 * @param fileUpdates - array of { path, content }
 */
async function updateFilesInBranch(
  octokit: ReturnType<typeof getOctokit>,
  owner: string,
  repo: string,
  branchName: string,
  fileUpdates: { path: string; content: string }[]
): Promise<void> {
  for (const { path: filePath, content } of fileUpdates) {
    const fileSha = await getFileSha(octokit, owner, repo, filePath, branchName);
    await octokit.rest.repos.createOrUpdateFileContents({
      owner,
      repo,
      path: filePath,
      message: `Update chart version in ${filePath} [Generated by Copilot]`,
      content: Buffer.from(content).toString('base64'),
      branch: branchName,
      sha: fileSha,
      committer: {
        name: 'github-actions[bot]',
        email: 'github-actions[bot]@users.noreply.github.com',
      },
      author: {
        name: 'github-actions[bot]',
        email: 'github-actions[bot]@users.noreply.github.com',
      },
    });
  }
}

/**
 * @description Create a pull request using octokit
 * @param octokit - github client
 * @param owner - repo owner
 * @param repo - repo name
 * @param branchName - branch name
 * @param chartsUpdated - list of chart directories updated
 * @param dependencyName - dependency name
 * @param newVersion - new chart version
 * @param baseBranch - base branch name
 */
async function createPullRequest(
  octokit: ReturnType<typeof getOctokit>,
  owner: string,
  repo: string,
  branchName: string,
  chartsUpdated: string[],
  dependencyName: string,
  newVersion: string,
  baseBranch: string
): Promise<void> {
  await octokit.rest.pulls.create({
    owner,
    repo,
    title: `${PR_TITLE_PREFIX}${dependencyName}`,
    head: branchName,
    base: baseBranch,
    body: `Update Helm chart dependency '${dependencyName}' to version ${newVersion} in charts: ${chartsUpdated.join(', ')}.`,
  });
}

/**
 * @description Main action runner
 * @returns Promise<void>
 */
export async function run(): Promise<void> {
  // Generated by Copilot
  try {
    const { serviceName, version, githubToken, chartPrefix, branch } = getInputs();

    const missingInputs = !serviceName || !version || !githubToken;
    if (missingInputs) {
      setFailed('Missing required inputs: service-name, version, github-token');
      return;
    }

    const octokit = getOctokit(githubToken);
    const { owner, repo } = githubContext.repo;

    const workspace = process.env.GITHUB_WORKSPACE ?? process.cwd();
    // Find all chart directories in workspace (top-level only), filter by chartPrefix if provided
    const chartDirs = fs.readdirSync(workspace).filter((dir) => {
      const hasPrefix = chartPrefix === '' || dir.startsWith(chartPrefix);
      const chartPath = path.join(workspace, dir, CHART_FILE_NAME);
      return hasPrefix && fs.existsSync(chartPath);
    });

    const fileUpdates: { path: string; content: string }[] = [];
    const updatedCharts: string[] = [];

    for (const chartDir of chartDirs) {
      try {
        const chartFiles = findChartFiles(chartDir);
        let chartUpdated = false;
        for (const absFilePath of chartFiles) {
          const relFilePath = `${chartDir}/${path.basename(absFilePath)}`;
          const updateResult = updateDependencyVersion(absFilePath, serviceName, version);
          const newContent = updateResult.newContent ?? '';
          if (updateResult.updated && newContent !== '') {
            fileUpdates.push({ path: relFilePath, content: updateResult.newContent });
            chartUpdated = true;
          }
        }
        if (chartUpdated) {
          updatedCharts.push(chartDir);
        }
      } catch (chartError) {
        warning(`Failed to process chart '${chartDir}': ${chartError instanceof Error ? chartError.message : ''}`);
      }
    }

    if (updatedCharts.length === 0) {
      info(`No charts required updating for dependency '${serviceName}'. No PR will be opened.`);
      return;
    }

    // PR title and branch name include chartPrefix if provided
    const chartsLabel = chartPrefix ? `${chartPrefix}*` : updatedCharts.join(', ');
    const branchName = `update-helm-chart-${chartsLabel}-${serviceName}-${version}`;

    // Create branch from base
    await createBranch(octokit, owner, repo, branch, branchName);

    // Update files in new branch
    await updateFilesInBranch(octokit, owner, repo, branchName, fileUpdates);

    // Create PR
    await createPullRequest(octokit, owner, repo, branchName, updatedCharts, serviceName, version, branch);

    info(`Successfully created PR to update dependency '${serviceName}' to version ${version} in charts: ${updatedCharts.join(', ')}`);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
    setFailed(`Action failed with error: ${errorMessage}`);
  }
}
