// Generated by Copilot

import * as fs from 'fs';
import { describe, it, expect, vi, beforeEach } from 'vitest';
import * as core from '@actions/core';
import * as github from '@actions/github';
import { run, getFileSha, updateChartYamlDependency, updateHelmfileReleaseVersion } from '../main.js';

vi.mock('@actions/core');
vi.mock('@actions/github');
vi.mock('fs');

/**
 * @typedef MockInputs - Inputs for the action
 */
interface MockInputs {
  readonly serviceName?: string;
  readonly version?: string;
  readonly githubToken?: string;
  readonly chartPrefix?: string;
  readonly branch?: string;
}

/**
 * @description Helper to mock getInput
 */
const createMockGetInput = (inputs: MockInputs = {}) => {
  return (name: string): string => {
    switch (name) {
      case 'service-name':
        return inputs.serviceName ?? 'test-service';
      case 'version':
        return inputs.version ?? '1.2.3';
      case 'github-token':
        return inputs.githubToken ?? 'ghp_testtoken';
      case 'chart-prefix':
        return inputs.chartPrefix ?? '';
      case 'branch':
        return inputs.branch ?? 'main';
      default:
        return '';
    }
  };
};

/**
 * @description Setup GitHub context
 */
const setupGitHubContext = () => {
  Object.defineProperty(github, 'context', {
    value: {
      repo: { owner: 'test-owner', repo: 'test-repo' },
    },
    configurable: true,
  });
};

describe('update-chart-dependency Action', () => {
  describe('updateChartYamlDependency', () => {
    it('should update dependency version in Chart.yaml', () => {
      const yamlContent = [
        'apiVersion: v2',
        'name: chart1',
        'version: 1.0.0',
        'dependencies:',
        '  - name: test-service',
        '    version: 0.0.1',
        '    repository: "https://example.com/charts"',
        '',
      ].join('\n');
      vi.spyOn(fs, 'readFileSync').mockReturnValue(yamlContent);
      const result = updateChartYamlDependency('/fake/path/Chart.yaml', 'test-service', '1.2.3');
      expect(result.updated).toBe(true);
      expect(result.oldVersion).toBe('0.0.1');
      expect(result.newVersion).toBe('1.2.3');
      expect(result.newContent).toContain('version: 1.2.3');
    });

    it('should not update if dependency version matches', () => {
      const yamlContent = ['dependencies:', '  - name: test-service', '    version: 1.2.3'].join('\n');
      vi.spyOn(fs, 'readFileSync').mockReturnValue(yamlContent);
      const result = updateChartYamlDependency('/fake/path/Chart.yaml', 'test-service', '1.2.3');
      expect(result.updated).toBe(false);
    });

    it('should return updated: false for invalid YAML', () => {
      vi.spyOn(fs, 'readFileSync').mockReturnValue('invalid: : yaml');
      const result = updateChartYamlDependency('/fake/path/Chart.yaml', 'test-service', '1.2.3');
      expect(result.updated).toBe(false);
    });
  });

  describe('updateHelmfileReleaseVersion', () => {
    it('should update release version in helmfile.yaml', () => {
      const yamlContent = ['releases:', '  - name: test-service', '    version: 0.0.1', '    chart: "repo/chart"', ''].join('\n');
      vi.spyOn(fs, 'readFileSync').mockReturnValue(yamlContent);
      const result = updateHelmfileReleaseVersion('/fake/path/helmfile.yaml', 'test-service', '2.0.0');
      expect(result.updated).toBe(true);
      expect(result.oldVersion).toBe('0.0.1');
      expect(result.newVersion).toBe('2.0.0');
      expect(result.newContent).toContain('version: 2.0.0');
    });

    it('should not update if release version matches', () => {
      const yamlContent = ['releases:', '  - name: test-service', '    version: 2.0.0'].join('\n');
      vi.spyOn(fs, 'readFileSync').mockReturnValue(yamlContent);
      const result = updateHelmfileReleaseVersion('/fake/path/helmfile.yaml', 'test-service', '2.0.0');
      expect(result.updated).toBe(false);
    });

    it('should return updated: false for invalid YAML', () => {
      vi.spyOn(fs, 'readFileSync').mockReturnValue('bad: : yaml');
      const result = updateHelmfileReleaseVersion('/fake/path/helmfile.yaml', 'test-service', '2.0.0');
      expect(result.updated).toBe(false);
    });
  });
  let mockGetInput: ReturnType<typeof vi.fn>;
  let mockSetFailed: ReturnType<typeof vi.fn>;
  let mockInfo: ReturnType<typeof vi.fn>;
  let mockWarning: ReturnType<typeof vi.fn>;
  let mockGetOctokit: ReturnType<typeof vi.fn>;

  beforeEach(() => {
    vi.clearAllMocks();
    mockGetInput = vi.fn(createMockGetInput());
    mockSetFailed = vi.fn();
    mockInfo = vi.fn();
    mockWarning = vi.fn();
    mockGetOctokit = vi.fn(() => ({
      rest: {
        git: {
          getRef: vi.fn().mockResolvedValue({ data: { object: { sha: 'base-sha' } } }),
          createRef: vi.fn().mockResolvedValue({}),
        },
        repos: {
          getContent: vi.fn().mockResolvedValue({ data: { sha: 'file-sha' } }),
          createOrUpdateFileContents: vi.fn().mockResolvedValue({}),
        },
        pulls: {
          create: vi.fn().mockResolvedValue({}),
        },
      },
    }));
    // GITHUB_WORKSPACE is an environment variable, not camelCase. This is intentional for mocking.
    // eslint-disable-next-line @typescript-eslint/naming-convention
    vi.stubGlobal('process', { env: { GITHUB_WORKSPACE: '/workspace' }, cwd: () => '/workspace' });
    vi.stubGlobal('fs', fs);
    (core.getInput as unknown) = mockGetInput;
    (core.setFailed as unknown) = mockSetFailed;
    (core.info as unknown) = mockInfo;
    (core.warning as unknown) = mockWarning;
    (github.getOctokit as unknown) = mockGetOctokit;
    setupGitHubContext();
  });

  it('should fail if required inputs are missing', async () => {
    mockGetInput = vi.fn(createMockGetInput({ serviceName: '', version: '', githubToken: '' }));
    (core.getInput as unknown) = mockGetInput;
    await run();
    expect(mockSetFailed).toHaveBeenCalledWith(expect.stringContaining('Missing required inputs'));
  });

  it('should not open PR if no charts require updating', async () => {
    /**
     * @description Mock Dirent object for readdirSync, matching { withFileTypes: true }
     */
    const mockDirent: fs.Dirent<Buffer> = {
      name: Buffer.from('chart1'),
      parentPath: '',
      isDirectory: () => true,
      isFile: () => false,
      isBlockDevice: () => false,
      isCharacterDevice: () => false,
      isSymbolicLink: () => false,
      isFIFO: () => false,
      isSocket: () => false,
    };
    vi.spyOn(fs, 'readdirSync').mockImplementation(() => [mockDirent]);
    vi.spyOn(fs, 'existsSync').mockReturnValue(false);
    vi.spyOn(fs, 'readFileSync').mockReturnValue('dependencies:\n  - name: test-service\n    version: 1.2.3');
    await run();
    expect(mockInfo).toHaveBeenCalledWith(expect.stringContaining('No charts required updating'));
  });

  it('should create PR if chart dependency is updated', async () => {
    const mockDirent: fs.Dirent<Buffer> = {
      name: Buffer.from('chart1'),
      parentPath: '',
      isDirectory: () => true,
      isFile: () => false,
      isBlockDevice: () => false,
      isCharacterDevice: () => false,
      isSymbolicLink: () => false,
      isFIFO: () => false,
      isSocket: () => false,
    };
    vi.spyOn(fs, 'readdirSync').mockImplementation(() => [mockDirent]);
    vi.spyOn(fs, 'existsSync').mockImplementation((filePath: fs.PathLike) => {
      // Only Chart.yaml exists for chart1
      if (typeof filePath === 'string') {
        return filePath === '/workspace/chart1/Chart.yaml';
      }
      return false;
    });
    vi.spyOn(fs, 'readFileSync').mockImplementation((filePath: fs.PathOrFileDescriptor) => {
      // Chart.yaml contains outdated version for test-service, with realistic structure
      if (typeof filePath === 'string' && filePath === '/workspace/chart1/Chart.yaml') {
        return [
          'apiVersion: v2',
          'name: chart1',
          'version: 1.0.0',
          'dependencies:',
          '  - name: test-service',
          '    version: 0.0.1',
          '    repository: "https://example.com/charts"',
          '',
        ].join('\n');
      }
      return '';
    });
    await run();
    expect(mockGetOctokit).toHaveBeenCalledWith('ghp_testtoken');
    expect(mockInfo).toHaveBeenCalledWith(expect.stringContaining('Successfully created PR'));
  });

  it('should warn if chart processing fails', async () => {
    const mockDirent: fs.Dirent<Buffer> = {
      name: Buffer.from('chart1'),
      parentPath: '',
      isDirectory: () => true,
      isFile: () => false,
      isBlockDevice: () => false,
      isCharacterDevice: () => false,
      isSymbolicLink: () => false,
      isFIFO: () => false,
      isSocket: () => false,
    };
    vi.spyOn(fs, 'readdirSync').mockImplementation(() => [mockDirent]);
    vi.spyOn(fs, 'existsSync').mockReturnValue(true);
    vi.spyOn(fs, 'readFileSync').mockImplementation(() => {
      throw new Error('read error');
    });
    await run();
    expect(mockWarning).toHaveBeenCalledWith(expect.stringContaining('Failed to process chart'));
  });

  it('should return undefined from getFileSha on error', async () => {
    const octokit = {
      rest: {
        repos: {
          getContent: vi.fn().mockRejectedValue(new Error('fail')),
        },
      },
    } as unknown as Parameters<typeof getFileSha>[0];
    const sha = await getFileSha(octokit, 'owner', 'repo', 'path', 'branch');
    expect(sha).toBeUndefined();
  });

  it('should call setFailed in run catch block', async () => {
    vi.spyOn(core, 'getInput').mockImplementation(() => {
      throw new Error('forced error');
    });
    await run();
    expect(mockSetFailed).toHaveBeenCalledWith(expect.stringContaining('Action failed with error:'));
  });
});
