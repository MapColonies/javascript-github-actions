// Generated by Copilot
// filepath: /home/schnitz/repos/libot/javascript-github-actions/actions/jira-pull-request-integration/main.ts
import * as core from '@actions/core';
import * as github from '@actions/github';
/**
 * Constants for the action
 */
const JIRA_STATUS_CONTEXT = 'jira/issue-validation';
const JIRA_COMMENT_IDENTIFIER = 'ðŸŽ« Related Jira Issue';
const SUCCESS_STATE = 'success';
const ERROR_STATE = 'error';
/**
 * Extracts Jira issue ID from PR title using regex pattern
 * @param title - The pull request title
 * @param pattern - The regex pattern to match Jira issues
 * @returns JiraCheckResult containing whether Jira issue was found and the issue ID
 */
function extractJiraIssue(title, pattern) {
    const regex = new RegExp(pattern);
    const match = title.match(regex);
    const hasMatchWithValue = match?.[0] !== undefined;
    if (hasMatchWithValue) {
        return {
            hasJira: true,
            jiraIssue: match[0],
        };
    }
    return { hasJira: false };
}
/**
 * Creates or updates commit status for Jira validation
 * @param octokit - GitHub API client
 * @param contextInfo - GitHub context information
 * @param jiraResult - Result of Jira issue check
 * @param jiraBaseUrl - Base URL for Jira instance
 */
async function setCommitStatus(octokit, contextInfo, jiraResult, jiraBaseUrl) {
    const { owner, repo, prSha } = contextInfo;
    const { hasJira, jiraIssue } = jiraResult;
    const statusState = hasJira ? SUCCESS_STATE : ERROR_STATE;
    const statusDescription = hasJira ? 'Jira issue found in PR title' : 'Jira issue required in PR title (format: MAPCO-1234)';
    const targetUrl = hasJira && jiraIssue ? `${jiraBaseUrl}/browse/${jiraIssue}` : undefined;
    await octokit.rest.repos.createCommitStatus({
        owner,
        repo,
        sha: prSha,
        state: statusState,
        // eslint-disable-next-line @typescript-eslint/naming-convention
        target_url: targetUrl,
        description: statusDescription,
        context: JIRA_STATUS_CONTEXT,
    });
}
/**
 * Finds existing bot comment with Jira link
 * @param octokit - GitHub API client
 * @param contextInfo - GitHub context information
 * @returns Comment ID if found, undefined otherwise
 */
async function findExistingJiraComment(octokit, contextInfo) {
    const { owner, repo, prNumber } = contextInfo;
    const comments = await octokit.rest.issues.listComments({
        owner,
        repo,
        // eslint-disable-next-line @typescript-eslint/naming-convention
        issue_number: prNumber,
    });
    const existingComment = comments.data.find((comment) => {
        const isBotUser = comment.user?.type === 'Bot';
        const hasJiraIdentifier = comment.body?.includes(JIRA_COMMENT_IDENTIFIER) === true;
        return isBotUser && hasJiraIdentifier;
    });
    return existingComment?.id;
}
/**
 * Creates or updates Jira link comment on pull request
 * @param octokit - GitHub API client
 * @param contextInfo - GitHub context information
 * @param jiraIssue - The Jira issue ID
 * @param jiraBaseUrl - Base URL for Jira instance
 */
async function createOrUpdateJiraComment(octokit, contextInfo, jiraIssue, jiraBaseUrl) {
    const { owner, repo, prNumber } = contextInfo;
    const jiraUrl = `${jiraBaseUrl}/browse/${jiraIssue}`;
    const commentBody = `ðŸŽ« **Related Jira Issue**: [${jiraIssue}](${jiraUrl})`;
    const existingCommentId = await findExistingJiraComment(octokit, contextInfo);
    if (existingCommentId !== undefined) {
        // Update existing comment
        await octokit.rest.issues.updateComment({
            owner,
            repo,
            // eslint-disable-next-line @typescript-eslint/naming-convention
            comment_id: existingCommentId,
            body: commentBody,
        });
        core.info(`Updated existing Jira comment for issue: ${jiraIssue}`);
    }
    else {
        // Create new comment
        await octokit.rest.issues.createComment({
            owner,
            repo,
            // eslint-disable-next-line @typescript-eslint/naming-convention
            issue_number: prNumber,
            body: commentBody,
        });
        core.info(`Created new Jira comment for issue: ${jiraIssue}`);
    }
}
/**
 * Extracts GitHub context information needed for the action
 * @param context - GitHub context
 * @returns GitHubContextInfo object
 */
function extractGitHubContext(context) {
    const { owner, repo } = context.repo;
    const prNumber = context.issue.number;
    const prTitle = context.payload.pull_request?.title ?? '';
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    const prSha = context.payload.pull_request?.head?.sha ?? '';
    return {
        owner,
        repo,
        prNumber,
        prTitle,
        prSha,
    };
}
/**
 * Main function that executes the GitHub action
 * @returns Promise<void>
 */
export async function run() {
    try {
        // Get inputs from action.yaml
        const token = core.getInput('github-token') || process.env.GITHUB_TOKEN;
        const jiraBaseUrl = core.getInput('jira-base-url');
        const jiraIssuePattern = core.getInput('jira-issue-pattern');
        // Validate required inputs
        const hasToken = token !== undefined && token !== '';
        if (!hasToken) {
            core.setFailed('GitHub token is required');
            return;
        }
        // Get GitHub context
        const context = github.context;
        const isPullRequestEvent = context.eventName === 'pull_request';
        if (!isPullRequestEvent) {
            core.warning('This action is designed to work with pull request events');
            return;
        }
        // Check if pull request payload exists
        const hasPullRequestPayload = context.payload.pull_request !== undefined;
        if (!hasPullRequestPayload) {
            core.setFailed('Pull request payload not found in context');
            return;
        }
        // Extract context information
        const contextInfo = extractGitHubContext(context);
        const octokit = github.getOctokit(token);
        core.info(`Processing PR #${contextInfo.prNumber}: "${contextInfo.prTitle}"`);
        // Extract Jira issue from PR title
        const jiraResult = extractJiraIssue(contextInfo.prTitle, jiraIssuePattern);
        const hasJiraIssue = jiraResult.hasJira && jiraResult.jiraIssue !== undefined;
        if (hasJiraIssue) {
            core.info(`Found Jira issue: ${jiraResult.jiraIssue}`);
        }
        else {
            core.warning('No Jira issue found in PR title');
        }
        // Set commit status based on Jira validation
        await setCommitStatus(octokit, contextInfo, jiraResult, jiraBaseUrl);
        core.info(`Set commit status: ${jiraResult.hasJira ? 'success' : 'error'}`);
        // Add or update Jira link comment if issue found
        if (hasJiraIssue && jiraResult.jiraIssue !== undefined) {
            await createOrUpdateJiraComment(octokit, contextInfo, jiraResult.jiraIssue, jiraBaseUrl);
        }
        core.info('Jira integration completed successfully');
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
        core.setFailed(`Action failed with error: ${errorMessage}`);
    }
}
